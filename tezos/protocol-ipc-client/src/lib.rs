// Copyright (c) SimpleStaking, Viable Systems and Tezedge Contributors
// SPDX-License-Identifier: MIT

use std::{
    path::{Path, PathBuf},
    process::Stdio,
    sync::Arc,
    time::Duration,
};

use async_ipc::{IpcError, IpcReceiver, IpcSender};
use crypto::hash::{ChainId, ContextHash, ProtocolHash};
use nix::{
    sys::signal::{self, Signal},
    unistd::Pid,
};
use slog::{info, warn, Level, Logger};
use tezos_messages::p2p::encoding::operation::Operation;
use tezos_protocol_ipc_messages::*;
use thiserror::Error;
use tokio::{
    io::{AsyncBufReadExt, BufReader},
    process::{Child, Command},
};

use tezos_api::{environment::TezosEnvironmentConfiguration, ffi::*};
use tezos_context_api::{
    ContextKeyOwned, ContextValue, PatchContext, StringTreeObject, TezosContextStorageConfiguration,
};

/// Errors generated by `protocol_runner`.
#[derive(Error, Debug)]
pub enum ProtocolRunnerError {
    #[error("Failed to spawn tezos protocol wrapper sub-process: {reason}")]
    SpawnError {
        #[from]
        reason: tokio::io::Error,
    },
    #[error("Failed to terminate/kill tezos protocol wrapper sub-process, reason: {reason}")]
    TerminateError { reason: String },
}

impl slog::Value for ProtocolRunnerError {
    fn serialize(
        &self,
        _record: &slog::Record,
        key: slog::Key,
        serializer: &mut dyn slog::Serializer,
    ) -> slog::Result {
        serializer.emit_arguments(key, &format_args!("{}", self))
    }
}

/// Protocol configuration (transferred via IPC from tezedge node to protocol_runner.
#[derive(Clone, Debug)]
pub struct ProtocolRunnerConfiguration {
    pub runtime_configuration: TezosRuntimeConfiguration,
    pub environment: TezosEnvironmentConfiguration,
    pub enable_testchain: bool,
    pub storage: TezosContextStorageConfiguration,
    pub executable_path: PathBuf,
    pub log_level: Level,
}

impl ProtocolRunnerConfiguration {
    pub fn new(
        runtime_configuration: TezosRuntimeConfiguration,
        environment: TezosEnvironmentConfiguration,
        enable_testchain: bool,
        storage: TezosContextStorageConfiguration,
        executable_path: PathBuf,
        log_level: Level,
    ) -> Self {
        Self {
            runtime_configuration,
            environment,
            enable_testchain,
            storage,
            executable_path,
            log_level,
        }
    }
}

// TODO: differentiate between writable and readonly?
#[derive(Clone)]
pub struct ProtocolRunnerInstance {
    // TODO: child handle here?
    configuration: ProtocolRunnerConfiguration,
    socket_path: PathBuf,
    executable_path: PathBuf,
    endpoint_name: String,
    tokio_runtime: tokio::runtime::Handle,
    log_level: Level,
}

impl ProtocolRunnerInstance {
    pub const PROCESS_TERMINATE_WAIT_TIMEOUT: Duration = Duration::from_secs(10);

    pub fn new(
        configuration: ProtocolRunnerConfiguration,
        socket_path: &Path,
        endpoint_name: String,
        tokio_runtime: &tokio::runtime::Handle,
    ) -> Self {
        let ProtocolRunnerConfiguration {
            executable_path,
            log_level,
            ..
        } = configuration.clone();
        // TODO: duplicating stuff from configuration
        Self {
            configuration,
            socket_path: socket_path.to_path_buf(),
            executable_path,
            endpoint_name,
            tokio_runtime: tokio_runtime.clone(),
            log_level,
        }
    }

    pub fn spawn(&self, log: Logger) -> Result<tokio::process::Child, ProtocolRunnerError> {
        let _guard = self.tokio_runtime.enter();
        let mut process = Command::new(&self.executable_path)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .arg("--socket-path")
            .arg(&self.socket_path)
            .arg("--endpoint")
            .arg(&self.endpoint_name)
            .arg("--log-level")
            .arg(&self.log_level.as_str().to_lowercase())
            .spawn()?;

        self.log_subprocess_output(&mut process, log.clone());

        Ok(process)
    }

    /// Give [`wait_timeout`] time to stop process, and after that if tries to terminate/kill it
    pub async fn wait_and_terminate_ref(
        process: &mut tokio::process::Child,
        wait_timeout: Duration,
        log: &Logger,
    ) -> Result<(), ProtocolRunnerError> {
        match tokio::time::timeout(wait_timeout, process.wait()).await {
            Ok(Ok(exit_status)) => {
                if exit_status.success() {
                    info!(log, "Exited successfuly");
                } else {
                    warn!(log, "Exited with status code: {}", exit_status);
                }
                Ok(())
            }
            Ok(Err(err)) => Self::terminate_or_kill(process, format!("{:?}", err)).await,
            Err(_) => Self::terminate_or_kill(process, "wait timeout exceeded".to_string()).await,
        }
    }

    /// Checks if process is running
    pub fn is_running(process: &mut tokio::process::Child) -> bool {
        matches!(process.try_wait(), Ok(None))
    }

    /// Logs exit status
    pub fn log_exit_status(process: &mut tokio::process::Child, log: &Logger) {
        match process.try_wait() {
            Ok(None) => (),
            Ok(Some(status)) => {
                if status.success() {
                    info!(log, "protocol-runner was closed normally");
                } else {
                    warn!(log, "protocol-runner exited with status code: {}", status);
                }
            }
            Err(err) => warn!(
                log,
                "failed to obtain protocol-runner exit status code: {:?}", err
            ),
        }
    }

    async fn terminate_or_kill(
        process: &mut Child,
        reason: String,
    ) -> Result<(), ProtocolRunnerError> {
        // try to send SIGINT (ctrl-c)
        if let Some(pid) = process.id() {
            let pid = Pid::from_raw(pid as i32);
            match signal::kill(pid, Signal::SIGINT) {
                Ok(_) => Ok(()),
                Err(sigint_error) => {
                    // (fallback) if SIGINT failed, we just kill process
                    match process.kill().await {
                        Ok(_) => Ok(()),
                        Err(kill_error) => Err(ProtocolRunnerError::TerminateError {
                            reason: format!(
                                "Reason for termination: {}, sigint_error: {}, kill_error: {}",
                                reason, sigint_error, kill_error
                            ),
                        }),
                    }
                }
            }
        } else {
            Ok(())
        }
    }

    /// Spawns a tokio task that will forward STDOUT and STDERR from the child
    /// process to slog's output
    fn log_subprocess_output(&self, process: &mut Child, log: Logger) {
        // Only launch logging task if the output port if present, otherwise log a warning.
        macro_rules! handle_output {
            ($tag:expr, $name:expr, $io:expr, $log:expr) => {{
                if let Some(out) = $io.take() {
                    let log = $log;
                    self.tokio_runtime.spawn(async move {
                        let reader = BufReader::new(out);
                        let mut lines = reader.lines();
                        loop {
                            match lines.next_line().await {
                                Ok(Some(line)) => info!(log, "[{}] {}", $tag, line),
                                Ok(None) => {
                                    info!(log, "[{}] {} closed.", $tag, $name);
                                    break;
                                }
                                Err(err) => {
                                    warn!(log, "[{}] {} closed with error: {:?}", $tag, $name, err);
                                    break;
                                }
                            }
                        }
                    });
                } else {
                    warn!(
                        log,
                        "Expected child process to have {}, but it was None", $name
                    );
                };
            }};
        }

        handle_output!("OCaml-out", "STDOUT", process.stdout, log.clone());
        handle_output!("OCaml-err", "STDERR", process.stderr, log.clone());
    }
}

struct IpcIO {
    rx: IpcReceiver<NodeMessage>,
    tx: IpcSender<ProtocolMessage>,
}

impl IpcIO {
    pub async fn send(&mut self, value: &ProtocolMessage) -> Result<(), async_ipc::IpcError> {
        self.tx.send(value).await?;
        Ok(())
    }

    pub async fn try_receive(
        &mut self,
        read_timeout: Option<Duration>,
    ) -> Result<NodeMessage, async_ipc::IpcError> {
        let result = self.rx.try_receive(read_timeout).await?;
        Ok(result)
    }
}

pub struct ProtocolRunnerApi {
    writable_instance: Arc<ProtocolRunnerInstance>,
}

impl ProtocolRunnerApi {
    pub fn new(writable_instance: ProtocolRunnerInstance) -> Self {
        Self {
            writable_instance: Arc::new(writable_instance),
        }
    }

    pub async fn writable_connection(&self) -> Result<ProtocolRunnerConnection, IpcError> {
        // TODO: pool connections
        let ipc_client = async_ipc::IpcClient::new(&self.writable_instance.socket_path);
        let (rx, tx) = ipc_client.connect().await?;
        let io = IpcIO { rx, tx };

        Ok(ProtocolRunnerConnection {
            instance: Arc::clone(&self.writable_instance),
            io,
        })
    }

    pub async fn readable_connection(&self) -> Result<ProtocolRunnerConnection, IpcError> {
        // TODO: reimplement once readonly instances have been added
        self.writable_connection().await
    }
}

pub struct ProtocolRunnerConnection {
    instance: Arc<ProtocolRunnerInstance>,
    io: IpcIO,
}

impl ProtocolRunnerConnection {
    const DEFAULT_TIMEOUT: Duration = Duration::from_secs(10);
    const DEFAULT_TIMEOUT_LONG: Duration = Duration::from_secs(300);
    const APPLY_BLOCK_TIMEOUT: Duration = Duration::from_secs(60 * 60 * 2);
    const INIT_PROTOCOL_CONTEXT_TIMEOUT: Duration = Duration::from_secs(60);
    const BEGIN_APPLICATION_TIMEOUT: Duration = Duration::from_secs(120);
    const BEGIN_CONSTRUCTION_TIMEOUT: Duration = Duration::from_secs(120);
    const VALIDATE_OPERATION_TIMEOUT: Duration = Duration::from_secs(120);
    const CALL_PROTOCOL_RPC_TIMEOUT: Duration = Duration::from_secs(30);
    const CALL_PROTOCOL_HEAVY_RPC_TIMEOUT: Duration = Duration::from_secs(600);
    const COMPUTE_PATH_TIMEOUT: Duration = Duration::from_secs(30);
    const JSON_ENCODE_DATA_TIMEOUT: Duration = Duration::from_secs(30);
    const ASSERT_ENCODING_FOR_PROTOCOL_DATA_TIMEOUT: Duration = Duration::from_secs(15);

    /// Apply block
    pub async fn apply_block(
        &mut self,
        request: ApplyBlockRequest,
    ) -> Result<ApplyBlockResponse, ProtocolServiceError> {
        self.io
            .send(&ProtocolMessage::ApplyBlockCall(request))
            .await?;
        println!("Called apply_block");
        // this might take a while, so we will use unusually long timeout
        match self.io.try_receive(Some(Self::APPLY_BLOCK_TIMEOUT)).await? {
            NodeMessage::ApplyBlockResult(result) => {
                result.map_err(|err| ProtocolError::ApplyBlockError { reason: err }.into())
            }
            message => Err(ProtocolServiceError::UnexpectedMessage {
                message: message.into(),
            }),
        }
    }

    pub async fn assert_encoding_for_protocol_data(
        &mut self,
        protocol_hash: ProtocolHash,
        protocol_data: RustBytes,
    ) -> Result<(), ProtocolServiceError> {
        self.io
            .send(&ProtocolMessage::AssertEncodingForProtocolDataCall(
                protocol_hash,
                protocol_data,
            ))
            .await?;

        // this might take a while, so we will use unusually long timeout
        match self
            .io
            .try_receive(Some(Self::ASSERT_ENCODING_FOR_PROTOCOL_DATA_TIMEOUT))
            .await?
        {
            NodeMessage::AssertEncodingForProtocolDataResult(result) => result.map_err(|err| {
                ProtocolError::AssertEncodingForProtocolDataError { reason: err }.into()
            }),
            message => Err(ProtocolServiceError::UnexpectedMessage {
                message: message.into(),
            }),
        }
    }

    /// Begin application
    pub async fn begin_application(
        &mut self,
        request: BeginApplicationRequest,
    ) -> Result<BeginApplicationResponse, ProtocolServiceError> {
        self.io
            .send(&ProtocolMessage::BeginApplicationCall(request))
            .await?;

        // this might take a while, so we will use unusually long timeout
        match self
            .io
            .try_receive(Some(Self::BEGIN_APPLICATION_TIMEOUT))
            .await?
        {
            NodeMessage::BeginApplicationResult(result) => {
                result.map_err(|err| ProtocolError::BeginApplicationError { reason: err }.into())
            }
            message => Err(ProtocolServiceError::UnexpectedMessage {
                message: message.into(),
            }),
        }
    }

    /// Begin construction
    pub async fn begin_construction(
        &mut self,
        request: BeginConstructionRequest,
    ) -> Result<PrevalidatorWrapper, ProtocolServiceError> {
        self.io
            .send(&ProtocolMessage::BeginConstructionCall(request))
            .await?;

        // this might take a while, so we will use unusually long timeout
        match self
            .io
            .try_receive(Some(Self::BEGIN_CONSTRUCTION_TIMEOUT))
            .await?
        {
            NodeMessage::BeginConstructionResult(result) => {
                result.map_err(|err| ProtocolError::BeginConstructionError { reason: err }.into())
            }
            message => Err(ProtocolServiceError::UnexpectedMessage {
                message: message.into(),
            }),
        }
    }

    /// Validate operation
    pub async fn validate_operation(
        &mut self,
        request: ValidateOperationRequest,
    ) -> Result<ValidateOperationResponse, ProtocolServiceError> {
        self.io
            .send(&ProtocolMessage::ValidateOperationCall(request))
            .await?;

        // this might take a while, so we will use unusually long timeout
        match self
            .io
            .try_receive(Some(Self::VALIDATE_OPERATION_TIMEOUT))
            .await?
        {
            NodeMessage::ValidateOperationResponse(result) => {
                result.map_err(|err| ProtocolError::ValidateOperationError { reason: err }.into())
            }
            message => Err(ProtocolServiceError::UnexpectedMessage {
                message: message.into(),
            }),
        }
    }

    /// ComputePath
    pub async fn compute_path(
        &mut self,
        request: ComputePathRequest,
    ) -> Result<ComputePathResponse, ProtocolServiceError> {
        self.io
            .send(&ProtocolMessage::ComputePathCall(request))
            .await?;

        // this might take a while, so we will use unusually long timeout
        match self
            .io
            .try_receive(Some(Self::COMPUTE_PATH_TIMEOUT))
            .await?
        {
            NodeMessage::ComputePathResponse(result) => {
                result.map_err(|err| ProtocolError::ComputePathError { reason: err }.into())
            }
            message => Err(ProtocolServiceError::UnexpectedMessage {
                message: message.into(),
            }),
        }
    }

    pub async fn apply_block_result_metadata(
        &mut self,
        context_hash: ContextHash,
        metadata_bytes: RustBytes,
        max_operations_ttl: i32,
        protocol_hash: ProtocolHash,
        next_protocol_hash: ProtocolHash,
    ) -> Result<String, ProtocolServiceError> {
        self.io
            .send(&ProtocolMessage::JsonEncodeApplyBlockResultMetadata(
                JsonEncodeApplyBlockResultMetadataParams {
                    context_hash,
                    max_operations_ttl,
                    metadata_bytes,
                    protocol_hash,
                    next_protocol_hash,
                },
            ))
            .await?;

        // this might take a while, so we will use unusually long timeout
        match self
            .io
            .try_receive(Some(Self::JSON_ENCODE_DATA_TIMEOUT))
            .await?
        {
            NodeMessage::JsonEncodeApplyBlockResultMetadataResponse(result) => {
                result.map_err(|err| {
                    ProtocolError::FfiJsonEncoderError {
                        caller: "apply_block_result_metadata".to_owned(),
                        reason: err,
                    }
                    .into()
                })
            }
            message => Err(ProtocolServiceError::UnexpectedMessage {
                message: message.into(),
            }),
        }
    }

    pub async fn apply_block_operations_metadata(
        &mut self,
        chain_id: ChainId,
        operations: Vec<Vec<Operation>>,
        operations_metadata_bytes: Vec<Vec<RustBytes>>,
        protocol_hash: ProtocolHash,
        next_protocol_hash: ProtocolHash,
    ) -> Result<String, ProtocolServiceError> {
        self.io
            .send(&ProtocolMessage::JsonEncodeApplyBlockOperationsMetadata(
                JsonEncodeApplyBlockOperationsMetadataParams {
                    chain_id,
                    operations,
                    operations_metadata_bytes,
                    protocol_hash,
                    next_protocol_hash,
                },
            ))
            .await?;

        // this might take a while, so we will use unusually long timeout
        match self
            .io
            .try_receive(Some(Self::JSON_ENCODE_DATA_TIMEOUT))
            .await?
        {
            NodeMessage::JsonEncodeApplyBlockOperationsMetadata(result) => result.map_err(|err| {
                ProtocolError::FfiJsonEncoderError {
                    caller: "apply_block_operations_metadata".to_owned(),
                    reason: err,
                }
                .into()
            }),
            message => Err(ProtocolServiceError::UnexpectedMessage {
                message: message.into(),
            }),
        }
    }

    /// Call protocol  rpc - internal
    async fn call_protocol_rpc_internal(
        &mut self,
        request_path: String,
        msg: ProtocolMessage,
    ) -> Result<ProtocolRpcResponse, ProtocolServiceError> {
        self.io.send(&msg).await?;

        // this might take a while, so we will use unusually long timeout
        match self
            .io
            .try_receive(Some(Self::CALL_PROTOCOL_HEAVY_RPC_TIMEOUT))
            .await?
        {
            NodeMessage::RpcResponse(result) => result.map_err(|err| {
                ProtocolError::ProtocolRpcError {
                    reason: err,
                    request_path,
                }
                .into()
            }),
            message => Err(ProtocolServiceError::UnexpectedMessage {
                message: message.into(),
            }),
        }
    }

    /// Call protocol rpc
    pub async fn call_protocol_rpc(
        &mut self,
        request: ProtocolRpcRequest,
    ) -> Result<ProtocolRpcResponse, ProtocolServiceError> {
        self.call_protocol_rpc_internal(
            request.request.context_path.clone(),
            ProtocolMessage::ProtocolRpcCall(request),
        )
        .await
    }

    /// Call helpers_preapply_* shell service - internal
    async fn call_helpers_preapply_internal(
        &mut self,
        msg: ProtocolMessage,
    ) -> Result<HelpersPreapplyResponse, ProtocolServiceError> {
        self.io.send(&msg).await?;

        // this might take a while, so we will use unusually long timeout
        match self
            .io
            .try_receive(Some(Self::CALL_PROTOCOL_RPC_TIMEOUT))
            .await?
        {
            NodeMessage::HelpersPreapplyResponse(result) => {
                result.map_err(|err| ProtocolError::HelpersPreapplyError { reason: err }.into())
            }
            message => Err(ProtocolServiceError::UnexpectedMessage {
                message: message.into(),
            }),
        }
    }

    /// Call helpers_preapply_operations shell service
    pub async fn helpers_preapply_operations(
        &mut self,
        request: ProtocolRpcRequest,
    ) -> Result<HelpersPreapplyResponse, ProtocolServiceError> {
        self.call_helpers_preapply_internal(ProtocolMessage::HelpersPreapplyOperationsCall(request))
            .await
    }

    /// Call helpers_preapply_block shell service
    pub async fn helpers_preapply_block(
        &mut self,
        request: HelpersPreapplyBlockRequest,
    ) -> Result<HelpersPreapplyResponse, ProtocolServiceError> {
        self.call_helpers_preapply_internal(ProtocolMessage::HelpersPreapplyBlockCall(request))
            .await
    }

    /// Change tezos runtime configuration
    pub async fn change_runtime_configuration(
        &mut self,
        settings: TezosRuntimeConfiguration,
    ) -> Result<(), ProtocolServiceError> {
        self.io
            .send(&ProtocolMessage::ChangeRuntimeConfigurationCall(settings))
            .await?;
        match self.io.try_receive(Some(Self::DEFAULT_TIMEOUT)).await? {
            NodeMessage::ChangeRuntimeConfigurationResult => Ok(()),
            message => Err(ProtocolServiceError::UnexpectedMessage {
                message: message.into(),
            }),
        }
    }

    /// Command tezos ocaml code to initialize context and protocol.
    /// CommitGenesisResult is returned only if commit_genesis is set to true
    async fn init_protocol_context(
        &mut self,
        storage: TezosContextStorageConfiguration,
        tezos_environment: &TezosEnvironmentConfiguration,
        commit_genesis: bool,
        enable_testchain: bool,
        readonly: bool,
        patch_context: Option<PatchContext>,
        context_stats_db_path: Option<PathBuf>,
    ) -> Result<InitProtocolContextResult, ProtocolServiceError> {
        // call init
        self.io
            .send(&ProtocolMessage::InitProtocolContextCall(
                InitProtocolContextParams {
                    storage,
                    genesis: tezos_environment.genesis.clone(),
                    genesis_max_operations_ttl: tezos_environment
                        .genesis_additional_data()
                        .map_err(|error| ProtocolServiceError::InvalidDataError {
                            message: format!("{:?}", error),
                        })?
                        .max_operations_ttl,
                    protocol_overrides: tezos_environment.protocol_overrides.clone(),
                    commit_genesis,
                    enable_testchain,
                    readonly,
                    turn_off_context_raw_inspector: true, // TODO - TE-261: remove later, new context doesn't use it
                    patch_context,
                    context_stats_db_path,
                },
            ))
            .await?;

        // wait for response
        // this might take a while, so we will use unusually long timeout
        match self
            .io
            .try_receive(Some(Self::INIT_PROTOCOL_CONTEXT_TIMEOUT))
            .await?
        {
            NodeMessage::InitProtocolContextResult(result) => {
                result.map_err(|err| ProtocolError::OcamlStorageInitError { reason: err }.into())
            }
            message => Err(ProtocolServiceError::UnexpectedMessage {
                message: message.into(),
            }),
        }
    }

    /// Gracefully shutdown protocol runner
    pub async fn shutdown(&mut self) -> Result<(), ProtocolServiceError> {
        // TODO: needed?
        //if self.shutting_down {
        //    // shutdown was already triggered before
        //    return Ok(());
        //}
        //self.shutting_down = true;

        // For shutdown messages we don't care if there are pending reads
        self.io.send(&ProtocolMessage::ShutdownCall).await?;

        match self.io.try_receive(Some(Self::DEFAULT_TIMEOUT)).await? {
            NodeMessage::ShutdownResult => Ok(()),
            message => Err(ProtocolServiceError::UnexpectedMessage {
                message: message.into(),
            }),
        }
    }

    /// Initialize protocol environment from default configuration (writeable).
    pub async fn init_protocol_for_write(
        &mut self,
        commit_genesis: bool,
        patch_context: &Option<PatchContext>,
        context_stats_db_path: Option<PathBuf>,
    ) -> Result<InitProtocolContextResult, ProtocolServiceError> {
        self.change_runtime_configuration(
            self.instance.configuration.runtime_configuration.clone(),
        )
        .await?;
        let environment = self.instance.configuration.environment.clone();
        self.init_protocol_context(
            self.instance.configuration.storage.clone(),
            &environment,
            commit_genesis,
            self.instance.configuration.enable_testchain,
            false,
            patch_context.clone(),
            context_stats_db_path,
        )
        .await
    }

    /// Initialize protocol environment from default configuration (readonly).
    pub async fn init_protocol_for_read(
        &mut self,
    ) -> Result<InitProtocolContextResult, ProtocolServiceError> {
        // TODO - TE-261: should use a different message exchange for readonly contexts?
        self.change_runtime_configuration(
            self.instance.configuration.runtime_configuration.clone(),
        )
        .await?;
        let environment = self.instance.configuration.environment.clone();
        self.init_protocol_context(
            self.instance.configuration.storage.clone(),
            &environment,
            false,
            self.instance.configuration.enable_testchain,
            true,
            None,
            None,
        )
        .await
    }

    // TODO - TE-261: this requires more descriptive errors.

    /// Initializes server to listen for readonly context clients through IPC.
    ///
    /// Must be called after the writable context has been initialized.
    pub async fn init_context_ipc_server(&mut self) -> Result<(), ProtocolServiceError> {
        if self
            .instance
            .configuration
            .storage
            .get_ipc_socket_path()
            .is_some()
        {
            self.io
                .send(&ProtocolMessage::InitProtocolContextIpcServer(
                    self.instance.configuration.storage.clone(),
                ))
                .await?;

            match self.io.try_receive(Some(Self::DEFAULT_TIMEOUT)).await? {
                NodeMessage::InitProtocolContextIpcServerResult(result) => {
                    result.map_err(|err| ProtocolServiceError::ContextIpcServerError {
                        message: format!("Failure when starting context IPC server: {}", err),
                    })
                }
                message => Err(ProtocolServiceError::UnexpectedMessage {
                    message: message.into(),
                }),
            }
        } else {
            Ok(())
        }
    }

    /// Gets data for genesis.
    pub async fn genesis_result_data(
        &mut self,
        genesis_context_hash: &ContextHash,
    ) -> Result<CommitGenesisResult, ProtocolServiceError> {
        let tezos_environment = self.instance.configuration.environment.clone();
        let main_chain_id = tezos_environment.main_chain_id().map_err(|e| {
            ProtocolServiceError::InvalidDataError {
                message: format!("{:?}", e),
            }
        })?;
        let protocol_hash = tezos_environment.genesis_protocol().map_err(|e| {
            ProtocolServiceError::InvalidDataError {
                message: format!("{:?}", e),
            }
        })?;

        self.io
            .send(&ProtocolMessage::GenesisResultDataCall(
                GenesisResultDataParams {
                    genesis_context_hash: genesis_context_hash.clone(),
                    chain_id: main_chain_id,
                    genesis_protocol_hash: protocol_hash,
                    genesis_max_operations_ttl: tezos_environment
                        .genesis_additional_data()
                        .map_err(|error| ProtocolServiceError::InvalidDataError {
                            message: format!("{:?}", error),
                        })?
                        .max_operations_ttl,
                },
            ))
            .await?;

        match self.io.try_receive(Some(Self::DEFAULT_TIMEOUT)).await? {
            NodeMessage::CommitGenesisResultData(result) => {
                result.map_err(|err| ProtocolError::GenesisResultDataError { reason: err }.into())
            }
            message => Err(ProtocolServiceError::UnexpectedMessage {
                message: message.into(),
            }),
        }
    }

    pub async fn get_context_key_from_history(
        &mut self,
        context_hash: &ContextHash,
        key: ContextKeyOwned,
    ) -> Result<Option<ContextValue>, ProtocolServiceError> {
        self.io
            .send(&ProtocolMessage::ContextGetKeyFromHistory(
                ContextGetKeyFromHistoryRequest {
                    context_hash: context_hash.clone(),
                    key,
                },
            ))
            .await?;

        match self
            .io
            .try_receive(Some(Self::DEFAULT_TIMEOUT_LONG))
            .await?
        {
            NodeMessage::ContextGetKeyFromHistoryResult(result) => result
                .map_err(|err| ProtocolError::ContextGetKeyFromHistoryError { reason: err }.into()),
            message => Err(ProtocolServiceError::UnexpectedMessage {
                message: message.into(),
            }),
        }
    }

    pub async fn get_context_key_values_by_prefix(
        &mut self,
        context_hash: &ContextHash,
        prefix: ContextKeyOwned,
    ) -> Result<Option<Vec<(ContextKeyOwned, ContextValue)>>, ProtocolServiceError> {
        self.io
            .send(&ProtocolMessage::ContextGetKeyValuesByPrefix(
                ContextGetKeyValuesByPrefixRequest {
                    context_hash: context_hash.clone(),
                    prefix,
                },
            ))
            .await?;

        match self
            .io
            .try_receive(Some(Self::DEFAULT_TIMEOUT_LONG))
            .await?
        {
            NodeMessage::ContextGetKeyValuesByPrefixResult(result) => result.map_err(|err| {
                ProtocolError::ContextGetKeyValuesByPrefixError { reason: err }.into()
            }),
            message => Err(ProtocolServiceError::UnexpectedMessage {
                message: message.into(),
            }),
        }
    }

    pub async fn get_context_tree_by_prefix(
        &mut self,
        context_hash: &ContextHash,
        prefix: ContextKeyOwned,
        depth: Option<usize>,
    ) -> Result<StringTreeObject, ProtocolServiceError> {
        self.io
            .send(&ProtocolMessage::ContextGetTreeByPrefix(
                ContextGetTreeByPrefixRequest {
                    context_hash: context_hash.clone(),
                    prefix,
                    depth,
                },
            ))
            .await?;

        match self
            .io
            .try_receive(Some(Self::DEFAULT_TIMEOUT_LONG))
            .await?
        {
            NodeMessage::ContextGetTreeByPrefixResult(result) => result.map_err(|err| {
                ProtocolError::ContextGetKeyValuesByPrefixError { reason: err }.into()
            }),
            message => Err(ProtocolServiceError::UnexpectedMessage {
                message: message.into(),
            }),
        }
    }
}

// Errors

/// Errors generated by `protocol_runner`.
#[derive(Error, Debug)]
pub enum ProtocolServiceError {
    /// Generic IPC communication error. See `reason` for more details.
    #[error("IPC error: {reason}")]
    IpcError {
        #[from]
        reason: IpcError,
    },
    /// Tezos protocol error.
    #[error("Protocol error: {reason}")]
    ProtocolError {
        #[from]
        reason: ProtocolError,
    },
    /// Unexpected message was received from IPC channel
    #[error("Received unexpected message: {message}")]
    UnexpectedMessage { message: &'static str },
    /// Invalid data error
    #[error("Invalid data error: {message}")]
    InvalidDataError { message: String },
    /// Lock error
    #[error("Lock error: {message:?}")]
    LockPoisonError { message: String },
    /// Context IPC server error
    #[error("Context IPC server error: {message:?}")]
    ContextIpcServerError { message: String },
}

impl<T> From<std::sync::PoisonError<T>> for ProtocolServiceError {
    fn from(source: std::sync::PoisonError<T>) -> Self {
        Self::LockPoisonError {
            message: source.to_string(),
        }
    }
}

impl slog::Value for ProtocolServiceError {
    fn serialize(
        &self,
        _record: &slog::Record,
        key: slog::Key,
        serializer: &mut dyn slog::Serializer,
    ) -> slog::Result {
        serializer.emit_arguments(key, &format_args!("{}", self))
    }
}

pub fn handle_protocol_service_error<LC: Fn(ProtocolServiceError)>(
    error: ProtocolServiceError,
    log_callback: LC,
) -> Result<(), ProtocolServiceError> {
    match error {
        ProtocolServiceError::IpcError { .. } | ProtocolServiceError::UnexpectedMessage { .. } => {
            // we need to refresh protocol runner endpoint, so propagate error
            Err(error)
        }
        _ => {
            // just log error
            log_callback(error);
            Ok(())
        }
    }
}
